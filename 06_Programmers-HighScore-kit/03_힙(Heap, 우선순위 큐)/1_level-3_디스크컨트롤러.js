/** https://school.programmers.co.kr/learn/courses/30/lessons/42627
 * 하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다.
 * 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다.
 *
 * 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.
 * - 0ms 시점에 3ms가 소요되는 A작업 요청
 * - 1ms 시점에 9ms가 소요되는 B작업 요청
 * - 2ms 시점에 6ms가 소요되는 C작업 요청
 * 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.
 *
 * 한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.
 * - A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
 * - B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
 * - C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
 * 이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.
 *
 * 하지만 A → C → B 순서대로 처리하면
 * - A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
 * - C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
 * - B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
 * 이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.
 *
 * @param {*} jobs 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열
 * @returns 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지
 * cf. 소수점 이하의 수는 버림
 *
 * ******* [풀이]
 * 스케줄링 알고리즘 중 최단 작업 우선 스케줄링(Shortest Job First, SJF)을 구현하는 문제
 * SJF는 운영체제의 스케줄러가 CPU 점유 시간이 가장 짧은 프로세스부터 우선적으로 할당하는 것
 * SJF는 `선점 최단작업 우선 스케줄링 알고리즘`과 `비선점 최단 작업 우선 스케줄링 알고리즘`이 있다
 *
 * **** 선점 최단 작업 우선 스케줄링 알고리즘 ✅
 * - `준비 상태 큐`에 도착한 프로세스의 CPU 점유 시간이 실행 중인 프로세스의 CPU 점유 시간보다 더 짧다면
 * - 실행 중인 프로세스를 멈추고 CPU 점유 시간이 더 짧은 프로세스를 실행
 *
 * **** 비선점 최단 작업 우선 스케줄링 알고리즘
 * - `준비 상태 큐`에 도착한 프로세스의 CPU 점유 시간이 가장 짧은 순서대로 프로세스를 실행한다.
 * - `선점 최단 작업 우선 스케줄링 알고리즘`과 다르게 이전 프로세스가 종료되어야 다음 프로세스가 실행 되기에
 * - 먼저 도착한 `프로세스의 CPU 점유 시간이 길면`, 나중에 도착한 `CPU 점유 시간이 짧은 프로세스`는 이전 프로세스의 실행이 끝날 때까지 대기한다.
 *
 * SJF방식에서 스케줄러는 CPU 작업 소요 시간을 예상해야 하는 어려움이 있다.
 * 또한 점유 시간이 짧은 프로세스 먼저 실행되기 때문에 점유 시간이 긴 프로세스는 실행되지 못할 수도 있다.
 */
function solution(jobs) {
  jobs.sort((a, b) => a[0] - b[0]) // 요청 시간 기준 오름차순
  const numOfJobs = jobs.length
  let queue = [] // 작업이 진행되는 동안 요청으로 들어온 작업들은 대기 queue
  let endTimeOfJob = 0
  let sumOfRequestToEndOfJob = 0

  // **** 모든 작업들을 queue에 올리고 순회
  // 작업이 종료된 후에 요청이 들어오면, queue가 비어있기 때문에 jobs길이도 순회
  while (queue.length || jobs.length) {
    // 진행중인 작업의 종료시간 전에 들어온 모든 요청을 queue에 적재
    while (jobs[0] && jobs[0][0] <= endTimeOfJob) {
      queue.push(jobs.shift())
    }
    // 작업 요청이 늦어 queue가 비어있을 경우 시간만 증가.
    if (!queue.length) {
      endTimeOfJob++
      continue
    }

    queue.sort((a, b) => a[1] - b[1]) // 작업 시간 기준 오름차순
    const [from, to] = queue.shift() // 작업 종료 후 queue에서 제거
    endTimeOfJob += to // 종료시간 업데이트
    sumOfRequestToEndOfJob += endTimeOfJob - from // 작업 완료시간 - 최초 요청시간
  }

  // *** 평균시간 정수로 반환, (3 + 7 + 17) / 3,  27 / 3 = 9
  return parseInt(sumOfRequestToEndOfJob / numOfJobs)
}

// prettier-ignore
console.log(solution([[0, 3], [1, 9], [2, 6]])); // 9
// 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다. (요청에서 종료까지 : 3ms)
// 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다. (요청에서 종료까지 : 7ms)
// 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다. (요청에서 종료까지 : 17ms)
// [요청시간, 작업시간]
