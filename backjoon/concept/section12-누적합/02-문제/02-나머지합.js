/*** https://www.acmicpc.net/problem/10986
 * [일반적인 구간 합 문제]
 * 기본적으로 배열에서 각 위치까지의 누적 합(prefix sum)을 이용한다.
 * 배열의 구간 합은 𝑠𝑢𝑚[𝑒𝑛𝑑] − 𝑠𝑢𝑚[𝑠𝑡𝑎𝑟𝑡 − 1]으로 𝑂(1)의 시간으로 계산할 수 있다.
 *
 * [예시]
 * 인덱스 0은 사용하지 않는다.
 * 𝑎𝑟𝑟 = 0, 3, 2, 5, 6, 7
 * 𝑠𝑢𝑚 = 0, 3, 5, 10, 16, 23
 * 1번째부터 4번째까지 구간 합: 𝑠𝑢𝑚 4 − 𝑠𝑢𝑚 0 = 16
 * 3번째부터 5번째까지 구간 합: 𝑠𝑢𝑚 5 − 𝑠𝑢𝑚 2 = 18
 *
 * [목표]
 * 연속 구간의 합이 M의 배수인 경우의 수를 구한다.
 * 𝑠𝑡𝑎𝑟𝑡, 𝑒𝑛𝑑 조합에 대해 𝑠𝑢𝑚 𝑒𝑛𝑑 − 𝑠𝑢𝑚 𝑠𝑡𝑎𝑟𝑡 − 1 % 𝑀 == 0인 개수를 구해야 한다.
 * 모듈로(%) 연산은 분배 법칙이 성립한다.
 * 𝑠𝑢𝑚 𝑒𝑛𝑑 % 𝑀 − 𝑠𝑢𝑚 𝑠𝑡𝑎𝑟𝑡 − 1 % 𝑀 == 0인 개수를 구하는 것과 같다.
 * 결과적으로 𝑠𝑢𝑚 𝑒𝑛𝑑 % 𝑀 == 𝑠𝑢𝑚 𝑠𝑡𝑎𝑟𝑡 − 1 % 𝑀인 개수를 구하는 문제로 치환된다.
 *
 * 실제로 구간 합 연산을 수행할 때 사용하는 것을 고려하면 𝑒𝑛𝑑 ≠ 𝑠𝑡𝑎𝑟𝑡 − 1이다.
 * 구간의 크기가 1인 경우인 𝑒𝑛𝑑 = 𝑠𝑡𝑎𝑟𝑡 인 상황이라고 해도 문제 없다.
 *
 * [문제 해결 방법]
 * 각 위치까지의 누적 합에 대하여 모듈로(%) 연산을 이용해 M으로 나눈 나머지를 저장한다.
 *
 * [문제 해결 방법]
 * 각 위치까지의 누적 합에 대하여 모듈로(%) 연산을 이용해 M으로 나눈 나머지를 저장한다.
 * 문제의 요구사항은 𝑝𝑟𝑜𝑐𝑒𝑠𝑠𝑒𝑑 배열에서 서로 다른 인덱스 (𝑥, 𝑦)에 대하여
 * 𝑝𝑟𝑜𝑐𝑒𝑠𝑠𝑒𝑑 𝑥 == 𝑝𝑟𝑜𝑐𝑒𝑠𝑠𝑒𝑑 𝑦 인 경우의 수를 세는 것과 같다.
 * 따라서, processed 배열에 존재하는 각 값에 대하여 카운트를 세준다.
 *
 * [예시] 특정한 값을 가지는 카운트가 5라고 하면, 5에서 2개를 고르는 조합의 수를 고려하면 된다.
 * → 5𝐶2 = 10 이다
 *
 * [예시 1]
 * 𝑁 = 10, 𝑀 = 5이고, 다음과 같다고 가정하자.
 * 𝑎𝑟𝑟 = 10, 4, 7, 8, 6, 9, 13, 12, 21, 24
 * 따라서, 누적 합은 다음과 같다.
 * 𝑠𝑢𝑚 = [10, 14, 21, 29, 35, 44, 57, 69, 90, 114]
 * 따라서, 누적 합을 𝑀으로 나눈 나머지는 다음과 같다.
 * 𝑝𝑟𝑜𝑐𝑒𝑠𝑠𝑒𝑑 = [0, 4, 1, 4, 0, 4, 2, 4, 0, 4]
 */
let file = require('fs').readFileSync('/dev/stdin')
let input = file.toString().split('\n')

let [n, m] = input[0].split(' ').map(Number)
let arr = [0, ...input[1].split(' ').map(Number)]

let sum = [0] // 누적 합(prefix sum)
for (let i = 1; i <= n; i++) {
  sum[i] = sum[i - 1] + arr[i]
}

let processed = [] // 누적 합(prefix sum)을 M으로 나눈 나머지
let counter = {} // 각 나머지 값에 대한 개수를 저장하고 있는 카운터
for (let i = 0; i <= n; i++) {
  processed[i] = sum[i] % m
  if (processed[i] in counter) counter[processed[i]] += 1
  else counter[processed[i]] = 1
}

let result = 0
for (let i = 0; i < m; i++) {
  // counter[i]개에서 2개를 고르는 조합
  if (i in counter) result += parseInt((counter[i] * (counter[i] - 1)) / 2)
}
console.log(result)
