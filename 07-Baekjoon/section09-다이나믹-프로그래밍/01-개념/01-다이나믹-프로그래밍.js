/*** 다이나믹 프로그래밍
 * 통상적으로 메모리를 더 사용하여 시간 복잡도를 개선할 때 많이 사용된다.
 * 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때,
 * 부분 문제의 반복이 발생하는 경우 적용하면 효과적이다.
 * 다이나믹 프로그래밍 문제를 해결하기 위해 점화식을 찾는 것이 핵심적인 과정이다
 */

/*** 다이나믹 프로그래밍의 사용 조건
 * 다이나믹 프로그래밍은 일반적으로 아래의 두 조건을 만족할 때 사용할 수 있다.
 * 1. 최적 부분 구조(optimal substructure)
 *    큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.
 *
 * 2. 반복되는 부분 문제(overlapping sub-problem)
 *    동일한 작은 문제를 반복적으로 해결해야 한다
 */

/*** 점화식과 최적 부분 구조
 * 피보나치 수열 예시: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …
 * 점화식: 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.
 * -> 일반적으로 최적 부분 구조를 만족한다는 특징이 있다.
 *
 * 피보나치 수열의 점화식: 𝑎𝑛 = 𝑎𝑛−1 + 𝑎𝑛−2 𝑎1 = 1, 𝑎2 = 1
 */

/*** 점화식의 구성요소
 * 점화식의 기본적인 구성 요소는 다음과 같다.
 * 1. 초기항
 * 2. 인접한 항과의 관계
 *
 * • 점화식은 [재귀 함수]로 표현할 수 있다.
 * • 재귀 함수는 [종료 조건]이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다
 */

/*** 점화식을 코드로 구현하는 방법
 * 점화식을 재귀 함수 코드로 구현할 수 있다.
 * 1. 점화식을 초기항은 종료 조건과 같은 역할을 수행한다.
 * 2. 점화식의 내용은 𝑓 𝑥 의 반환 값에 들어간다
 */

// 피보나치 함수(Fibonacci Function)을 재귀함수로 구현
function fibo(x) {
  // 종료 조건이 없으면 무한 루프
  if (x == 1 || x == 2) {
    return 1
  }
  // 실질적인 점화식 부분
  return fibo(x - 1) + fibo(x - 2)
}
console.log(fibo(4))

/*** 피보나치 수열 문제
 * 피보나치 수열 문제는 다음의 조건을 만족한다.
 * 1. 최적 부분 구조 → 점화식 형태로 표현 가능
 * 2. 반복되는 부분 문제
 * 이미 해결한 문제를 또 해결해야 한다
 */

/*** 다이나믹 프로그래밍의 일반 형태
 * 피보나치 수열의 점화식을 그대로 재귀 함수로 구현하면 어떻게 될까?
 * → 중복되는 부분 문제가 발생한다. (이미 구한 값을 불필요하게 반복 계산)
 * 다이나믹 프로그래밍은 이 문제를 해결할 수 있도록 해준다
 */

/*** 다이나믹 프로그래밍의 일반 형태
 * 다이나믹 프로그래밍(재귀 함수)의 대표적인 코드 형식은 다음과 같다
 * function dp() {
 * 	1. 종료 조건
 * 	2. 이미 해결한 문제라면, 정답을 그대로 반환
 * 	3. 점화식에 따라 정답 계산
 * }
 */

/*** 다이나믹 프로그래밍 문제 해결 과정
 * 다이나믹 프로그래밍 문제 해결 접근 순서는 다음과 같다.
 * 1. 문제 이해하기
 * 2. 점화식 찾아내기 → 일반적으로 가장 핵심적인 부분이다.
 * 3. 구현 방식(상향식/하향식) 결정하기
 * 4. 점화식을 실제 코드로 구현하기
 */

/*** 다이나믹 프로그래밍 문제 접근 방법
 * 다이나믹 프로그래밍 문제는 두 가지 방법으로 접근할 수 있다.
 * 1. 상향식: 반복문을 이용해 초기 항부터 계산한다.
 * 2. 하향식: 재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식이다.
 * → 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라고 한다
 */
