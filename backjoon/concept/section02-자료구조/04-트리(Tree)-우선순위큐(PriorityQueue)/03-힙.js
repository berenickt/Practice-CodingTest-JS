/*** 힙(heap)
 * 원소들 중에서 최댓값 혹은 최솟값을 빠르게 찾아내는 자료구조
 * - 최대 힙(max heap) : 값이 큰 원소부터 추출
 * - 최소 힙(min heap) : 값이 작은 원소부터 추출
 *
 * 원소의 삽입과 삭제를 위해 𝑂(log𝑁)의 수행시간을 요구
 * 단순한 𝑁개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일
 * 이 경우 시간복잡도는 𝑂(Nlog𝑁)
 */

/*** 최대 힙(Max Heap)
 * 부모 노드가 자식 노드보다 값이 큰 `완전 이진 트리`
 * 루트 노드는 전체 트리에서 가장 큰 값을 가진다는 특징
 */

/*** 힙(Heap)의 특징
 * 힙은 완전 이진 트리 자료구조를 따른다.
 * 힙에서는 우선순위가 높은 노드가 루트(root)에 위치한다.
 *
 * **** 최대 힙(max heap)
 * 부모노드의키값이자식노드의키값보다항상크다.
 * 루트 노드가 가장 크며, 값이 큰 데이터가 우선순위를 가진다.
 *
 * **** 최소 힙(min heap)
 * 부모노드의키값이자식노드의키값보다항상작다.
 * 루트 노드가 가장 작으며, 값이 작은 데이터가 우선순위를 가진다.
 */

/*** 최소 힙 구성 함수: Heapify - 힙을 만드는 함수
 *
 * **** 힙에 새 원소 추가
 * (상향식) 부모로 거슬러 올라가며, 부모보다 자신이 더 작은 경우에 위치를 교체
 * 새로운 원소가 삽입되었을때 𝑂(logN)의 시간복잡도로 힙 성질을 유지하도록 할 수 있다.
 *
 * **** 힙에 새 원소 삭제
 * 새로운 원소가 삽입되었을때 𝑂(logN)의 시간복잡도로 힙 성질을 유지하도록 할 수 있다.
 * 원소를 제거할때는 가장 마지막 노드가 루트 노드의 위치에 오도록 한다.
 * 이후에 루트 노드에서부터 하향식으로(더 작은 자식 노드로) heapify()를 진행한다.
 */

/*** 힙(Heap)의 특징
 * 힙의 삽입과 삭제 연산을 수행할 떄를 고려해봅시다.
 * 직관적으로, 거슬러 갈 때마다 처리해야 하는 범위에 포함된 원소의 개수가 절반씩 줄어든다.
 * 따라서 삽입과 삭제에 대한 시간복잡도는 𝑂(logN)
 */

/*** JavaScript의 힙(Heap) 라이브러리
 * JavaScript는 기본적으로 우선순위 큐를 라이브러리로 제공하지 않는다.
 * 최단 경로 알고리즘 등에서 힙(heap)이 필요한 경우 `별도의 라이브러리를 사용`해야 한다.
 */
